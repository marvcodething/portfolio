/**
 * Chat API Route for Portfolio RAG Chatbot
 * Simplified version with direct API calls
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { GoogleGenerativeAI } from '@google/generative-ai';

// Simple in-memory rate limiting (for production, use Redis or similar)
const rateLimitMap = new Map();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute
const MAX_REQUESTS_PER_WINDOW = 10; // 10 requests per minute

// Cleanup old entries every 5 minutes to prevent memory leaks
setInterval(() => {
  const now = Date.now();
  const windowStart = now - RATE_LIMIT_WINDOW;
  
  for (const [ip, requests] of rateLimitMap.entries()) {
    const recentRequests = requests.filter(time => time > windowStart);
    if (recentRequests.length === 0) {
      rateLimitMap.delete(ip);
    } else {
      rateLimitMap.set(ip, recentRequests);
    }
  }
}, 5 * 60 * 1000); // Cleanup every 5 minutes

function checkRateLimit(ip) {
  const now = Date.now();
  const windowStart = now - RATE_LIMIT_WINDOW;
  
  if (!rateLimitMap.has(ip)) {
    rateLimitMap.set(ip, []);
  }
  
  const requests = rateLimitMap.get(ip);
  const recentRequests = requests.filter(time => time > windowStart);
  
  if (recentRequests.length >= MAX_REQUESTS_PER_WINDOW) {
    return false;
  }
  
  recentRequests.push(now);
  rateLimitMap.set(ip, recentRequests);
  return true;
}

// Initialize clients
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
);

const ai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

async function generateEmbedding(text) {
  const model = ai.getGenerativeModel({ model: 'text-embedding-004' });
  const response = await model.embedContent(text);
  return response.embedding.values;
}

function formatLinksInResponse(text) {
  // Define known project URLs and their display names
  const urlMappings = {
    // GitHub repositories
    'github.com/marvcodething/international_law_model': 'Legal AI Platform (GitHub)',
    'github.com/marvcodething/twitter-clone': 'Twitter Clone (GitHub)', 
    'github.com/marvcodething/notesapp': 'Notes App (GitHub)',
    'github.com/marvcodething/rose-website': 'ROSE Website (GitHub)',
    'github.com/marvcodething/loanPrediction': 'Loan Calculator (GitHub)',
    'github.com/MA0610/SchedulingWebsite': 'Schedule Manager (GitHub)',
    'github.com/marvcodething/MushieWorld': 'Mushie World (GitHub)',
    'github.com/marvcodething': 'My GitHub Profile',
    
    // Live sites
    'studyspotapp.com': 'StudySpot',
    'stomping.site': 'stomping ground',
    'rose-union.org': 'ROSE Union',
    'marvinromero.online': 'My Portfolio',
    'twitter-clone-lxyw.onrender.com/login': 'Twitter Clone (Live Demo)',
    'notesapp-phi-gilt.vercel.app': 'Notes App (Live Demo)',
    'loanprediction-rxir.onrender.com': 'Loan Calculator (Live Demo)',
    
    // Social links
    'www.linkedin.com/in/marvin-romero': 'My LinkedIn',
    'linkedin.com/in/marvin-romero': 'My LinkedIn'
  };
  
  let formattedText = text;
  
  // Process each URL mapping
  Object.entries(urlMappings).forEach(([url, displayName]) => {
    // Create patterns for both with and without https://
    const patterns = [
      new RegExp(`https?://${url.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(?!/[^\\s<>"]*[a-zA-Z])`, 'gi'),
      new RegExp(`\\b${url.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(?!/[^\\s<>"]*[a-zA-Z])`, 'gi')
    ];
    
    patterns.forEach(pattern => {
      formattedText = formattedText.replace(pattern, (match) => {
        // Skip if this URL is already part of an HTML link
        if (formattedText.includes(`href="${match}"`) || 
            formattedText.includes(`href="https://${match}"`) ||
            formattedText.includes(`href="http://${match}"`)) {
          return match;
        }
        
        // Skip if this URL is already part of a partially formatted link
        if (formattedText.includes(`target="_blank"`) && 
            (formattedText.includes(displayName) || formattedText.includes(url))) {
          return match;
        }
        
        const href = match.startsWith('http') ? match : `https://${match}`;
        return `<a href="${href}" target="_blank" rel="noopener noreferrer" style="color: #ec4899; text-decoration: underline;">${displayName}</a>`;
      });
    });
  });
  
  // Clean up any malformed HTML that might have been generated by the AI
  formattedText = formattedText.replace(/target="_blank" rel="noopener noreferrer" style="color: #ec4899; text-decoration: underline;">([^<]+)<\/a>/g, (match, linkText) => {
    // Extract the URL from the malformed HTML and recreate it properly
    const urlMatch = formattedText.match(/href="([^"]+)"/);
    if (urlMatch) {
      const url = urlMatch[1];
      return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: #ec4899; text-decoration: underline;">${linkText}</a>`;
    }
    return match;
  });
  
  return formattedText;
}

async function searchRelevantContent(query, threshold = 0.6, limit = 3) {
  try {
    console.log(`ðŸ” Searching for: "${query}"`);
    
    const queryEmbedding = await generateEmbedding(query);
    console.log(`ðŸ“Š Generated embedding with ${queryEmbedding.length} dimensions`);
    
    // Format embedding as PostgreSQL array string
    const embeddingString = `[${queryEmbedding.join(',')}]`;
    console.log(`ðŸ”§ Formatted embedding for database search`);
    
    const { data, error } = await supabase.rpc('search_chunks', {
      query_embedding: embeddingString,
      match_threshold: threshold,
      match_count: limit
    });
    
    if (error) {
      console.error('âŒ Database search error:', error);
      throw error;
    }
    
    console.log(`âœ… Database search completed: ${data ? data.length : 0} results`);
    if (data && data.length > 0) {
      console.log(`ðŸŽ¯ Top result: ${data[0].category} (similarity: ${data[0].similarity})`);
    }
    
    return data || [];
  } catch (error) {
    console.error('âŒ Search function failed:', error);
    return [];
  }
}

async function generateResponse(query, context, conversationHistory = []) {
  try {
    const model = ai.getGenerativeModel({ 
      model: 'gemini-1.5-flash',
      generationConfig: {
        maxOutputTokens: 500,
        temperature: 0.7,
      },
    });
    
    const contextText = context.length > 0 
      ? context.map(item => `[${item.category}] ${item.content}`).join('\n\n')
      : '';
    
    // Format conversation history
    const historyText = conversationHistory.length > 0
      ? '\n\nPrevious conversation:\n' + conversationHistory.map(msg => 
          `${msg.role === 'user' ? 'User' : 'You'}: ${msg.content}`
        ).join('\n')
      : '';
    
    const systemPrompt = `You are Marvin Romero. Respond in first person using "I", "my", "me". Use the context below to answer questions about your background, skills, projects, and experience.

Context about yourself:
${contextText}${historyText}

Instructions:
- Respond in first person as Marvin Romero
- Use the information provided in the context above to answer questions
- Be conversational and professional
- Look at the previous conversation to avoid repeating the same information
- If you already mentioned certain projects/details, focus on different ones or provide additional details
- When mentioning projects, include complete URLs exactly as they appear in the context
- Always use full URLs like "github.com/marvcodething/project-name" not partial references
- For projects with GitHub repositories, include the complete GitHub URL
- For live demos, include the complete demo URL
- If someone asks for links, provide all available complete URLs including GitHub, live sites, and portfolio links
- You can rephrase and summarize information from the context
- Do NOT add personal details, locations, or experiences not mentioned in the context
- If you don't have enough relevant context to answer, say so
- IMPORTANT: Always format links as plain URLs (e.g., "github.com/marvcodething/project-name") - the system will automatically convert them to clickable links
- NEVER use markdown formatting like [text](url) or HTML tags in your responses
- NEVER include inline styles or HTML attributes in your responses

User question: ${query}`;

    const response = await model.generateContent(systemPrompt);
    
    if (!response || !response.response || !response.response.text()) {
      throw new Error('Invalid response from Gemini');
    }
    
    let responseText = response.response.text().trim();
    
    // Clean up any HTML that the AI might have generated
    responseText = responseText.replace(/<a[^>]*>([^<]*)<\/a>/g, '$1');
    responseText = responseText.replace(/href="[^"]*"/g, '');
    responseText = responseText.replace(/target="_blank"/g, '');
    responseText = responseText.replace(/rel="noopener noreferrer"/g, '');
    responseText = responseText.replace(/style="[^"]*"/g, '');
    
    // Convert URLs to clickable links
    responseText = formatLinksInResponse(responseText);
    
    return responseText;
  } catch (error) {
    console.error('Generation error:', error);
    return "I'm sorry, I'm having trouble generating a response right now. Please try again.";
  }
}

export async function POST(request) {
  try {
    // Rate limiting
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown';
    if (!checkRateLimit(ip)) {
      return NextResponse.json(
        { error: 'Rate limit exceeded. Please try again later.' },
        { status: 429 }
      );
    }
    
    const body = await request.json();
    const { message, conversationHistory = [] } = body;
    
    // Validate input
    if (!message || typeof message !== 'string' || message.trim().length === 0) {
      return NextResponse.json(
        { error: 'Message is required and must be a non-empty string' },
        { status: 400 }
      );
    }
    
    if (message.length > 1000) {
      return NextResponse.json(
        { error: 'Message too long. Please keep messages under 1000 characters.' },
        { status: 400 }
      );
    }
    
    console.log(`Processing query: "${message.substring(0, 100)}${message.length > 100 ? '...' : ''}"`);
    
    // Search for relevant content with lower threshold
    const relevantContent = await searchRelevantContent(message, 0.3, 5); // Lower threshold, more results
    console.log(`Found ${relevantContent.length} relevant chunks`);
    
    // Debug: Log search details
    if (relevantContent.length > 0) {
      console.log('Top result:', {
        category: relevantContent[0].category,
        similarity: relevantContent[0].similarity,
        preview: relevantContent[0].content.substring(0, 100)
      });
    } else {
      console.log('No relevant content found - debugging search...');
    }
    
    // Generate response using RAG
    const response = await generateResponse(message, relevantContent, conversationHistory);
    
    return NextResponse.json({
      success: true,
      message: response,
      metadata: {
        relevantChunks: relevantContent.length,
        sources: relevantContent.map(chunk => chunk.category),
        processingTime: Date.now() // Simple timestamp
      }
    });
    
  } catch (error) {
    console.error('Chat API error:', error);
    
    return NextResponse.json(
      { 
        error: 'An unexpected error occurred',
        success: false 
      },
      { status: 500 }
    );
  }
}

// Optional: GET endpoint for health check
export async function GET() {
  try {
    // Test connections
    const { data, error } = await supabase.from('document_chunks').select('count', { count: 'exact', head: true });
    
    return NextResponse.json({
      success: true,
      status: 'healthy',
      database: !error ? 'connected' : 'error',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Health check failed', success: false },
      { status: 500 }
    );
  }
}